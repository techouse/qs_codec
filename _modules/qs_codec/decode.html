<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>qs_codec.decode &#8212; qs-codec 1.3.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=27fed22d" />
    <script src="../../_static/documentation_options.js?v=1f29e9d3"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for qs_codec.decode</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Query string **decoder** (a.k.a. parser) with feature parity to the Node.js `qs` package.</span>

<span class="sd">Highlights</span>
<span class="sd">----------</span>
<span class="sd">- Accepts either a raw query string or a pre-tokenized mapping (mirrors `qs.parse`).</span>
<span class="sd">- Supports RFC 3986 / 1738 percent-decoding via `DecodeOptions.decoder`.</span>
<span class="sd">- Handles bracket notation, indices, dotted keys (opt-in), and duplicate keys strategies.</span>
<span class="sd">- Respects list parsing limits, depth limits, and charset sentinels (`utf8=%E2%9C%93` / `utf8=%26%2310003%3B`).</span>
<span class="sd">- Returns plain `dict` / `list` containers and never mutates the callerâ€™s input.</span>

<span class="sd">This module intentionally keeps the control flow close to the original reference implementation</span>
<span class="sd">so that behavior across ports stays predictable and easy to verify with shared test vectors.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">t</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">replace</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">isinf</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.enums.charset</span><span class="w"> </span><span class="kn">import</span> <span class="n">Charset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.enums.decode_kind</span><span class="w"> </span><span class="kn">import</span> <span class="n">DecodeKind</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.enums.duplicates</span><span class="w"> </span><span class="kn">import</span> <span class="n">Duplicates</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.enums.sentinel</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sentinel</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.models.decode_options</span><span class="w"> </span><span class="kn">import</span> <span class="n">DecodeOptions</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.models.undefined</span><span class="w"> </span><span class="kn">import</span> <span class="n">UNDEFINED</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils.decode_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">DecodeUtils</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">Utils</span>


<div class="viewcode-block" id="decode">
<a class="viewcode-back" href="../../qs_codec.html#qs_codec.decode.decode">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">decode</span><span class="p">(</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">]]],</span>
    <span class="n">options</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">DecodeOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decode a query string (or a pre-tokenized mapping) into a nested ``Dict[str, Any]``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value:</span>
<span class="sd">        Either a raw query string (``str``) or an already-parsed mapping (``Mapping[str, Any]``).</span>
<span class="sd">        Passing a mapping is useful in tests or when a custom tokenizer is used upstream.</span>
<span class="sd">    options:</span>
<span class="sd">        ``DecodeOptions`` controlling delimiter, duplicates policy, list &amp; depth limits, dot-notation, decoding charset, and more.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dict[str, Any]</span>
<span class="sd">        A freshly-allocated mapping containing nested dicts/lists/values.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``value`` is neither ``str`` nor ``Mapping``, or when limits are violated under ``raise_on_limit_exceeded=True``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Empty/falsey ``value`` returns an empty dict.</span>
<span class="sd">    - When the *number of top-level tokens* exceeds ``list_limit`` and ``parse_lists`` is enabled, the parser temporarily **disables list parsing** for this invocation to avoid quadratic work. This mirrors the behavior of other ports and keeps large flat query strings efficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;value must be a str or a Mapping[str, Any]&quot;</span><span class="p">)</span>

    <span class="c1"># Work on a local copy so any internal toggles don&#39;t leak to caller</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">DecodeOptions</span><span class="p">()</span>

    <span class="c1"># Temporarily toggle parse_lists for THIS call only, and only for raw strings</span>
    <span class="n">orig_parse_lists</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">parse_lists</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">orig_parse_lists</span><span class="p">:</span>
            <span class="c1"># Pre-count parameters so we can decide on toggling before tokenization/decoding</span>
            <span class="n">_s</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">ignore_query_prefix</span> <span class="k">else</span> <span class="n">value</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">):</span>
                <span class="n">_parts_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">_s</span><span class="p">))</span> <span class="k">if</span> <span class="n">_s</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_parts_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">_s</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">delimiter</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">_s</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">opts</span><span class="o">.</span><span class="n">list_limit</span> <span class="o">&lt;</span> <span class="n">_parts_count</span><span class="p">:</span>
                <span class="n">opts</span><span class="o">.</span><span class="n">parse_lists</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">temp_obj</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">_parse_query_string_values</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Iterate over the keys and setup the new object</span>
        <span class="k">if</span> <span class="n">temp_obj</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">temp_obj</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">new_obj</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span> <span class="o">=</span> <span class="n">_parse_keys</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">new_obj</span>
                    <span class="k">continue</span>

                <span class="n">obj</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">,</span> <span class="n">opts</span><span class="p">)</span>  <span class="c1"># type: ignore [assignment]</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">opts</span><span class="o">.</span><span class="n">parse_lists</span> <span class="o">=</span> <span class="n">orig_parse_lists</span>

    <span class="k">return</span> <span class="n">Utils</span><span class="o">.</span><span class="n">compact</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>



<span class="c1"># Alias for decode function</span>
<span class="n">load</span> <span class="o">=</span> <span class="n">decode</span>


<div class="viewcode-block" id="loads">
<a class="viewcode-back" href="../../qs_codec.html#qs_codec.decode.loads">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">loads</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">options</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">DecodeOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Alias for ``decode``. Decodes a query string into a ``Dict[str, Any]``.</span>

<span class="sd">    Use ``decode`` if you want to pass a ``Dict[str, Any]``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">decode</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_interpret_numeric_entities</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert HTML numeric entities (e.g., ``&amp;#169;``) to their character equivalents.</span>

<span class="sd">    Only used when ``options.interpret_numeric_entities`` is True and the effective charset</span>
<span class="sd">    is Latin-1; see the Node `qs` compatibility behavior.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&amp;#(\d+);&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">match</span><span class="p">:</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span> <span class="n">value</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_array_value</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">DecodeOptions</span><span class="p">,</span> <span class="n">current_list_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Post-process a raw scalar for list semantics and enforce ``list_limit``.</span>

<span class="sd">    Behavior</span>
<span class="sd">    --------</span>
<span class="sd">    - If ``comma=True`` and ``value`` is a string that contains commas, split into a list.</span>
<span class="sd">    - Otherwise, enforce the per-list length limit by comparing ``current_list_length`` to ``options.list_limit``.</span>
<span class="sd">      When ``raise_on_limit_exceeded=True``, violations raise ``ValueError``.</span>
<span class="sd">    - When ``list_limit`` is negative:</span>
<span class="sd">        * if ``raise_on_limit_exceeded=True``, **any** list-growth operation here (e.g., comma-splitting)</span>
<span class="sd">          raises immediately;</span>
<span class="sd">        * if ``raise_on_limit_exceeded=False`` (default), comma-splitting still returns a list; numeric</span>
<span class="sd">          bracket indices are handled later by ``_parse_object`` (where negative ``list_limit`` disables</span>
<span class="sd">          numeric-index parsing only).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Any</span>
<span class="sd">        Either the original value or a list of values, without decoding (that happens later).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">comma</span> <span class="ow">and</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
        <span class="n">split_val</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">raise_on_limit_exceeded</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_val</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">options</span><span class="o">.</span><span class="n">list_limit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;List limit exceeded: Only </span><span class="si">{</span><span class="n">options</span><span class="o">.</span><span class="n">list_limit</span><span class="si">}</span><span class="s2"> element</span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">options</span><span class="o">.</span><span class="n">list_limit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;s&#39;</span><span class="si">}</span><span class="s2"> allowed in a list.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">split_val</span>

    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">raise_on_limit_exceeded</span> <span class="ow">and</span> <span class="n">current_list_length</span> <span class="o">&gt;=</span> <span class="n">options</span><span class="o">.</span><span class="n">list_limit</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;List limit exceeded: Only </span><span class="si">{</span><span class="n">options</span><span class="o">.</span><span class="n">list_limit</span><span class="si">}</span><span class="s2"> element</span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">options</span><span class="o">.</span><span class="n">list_limit</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;s&#39;</span><span class="si">}</span><span class="s2"> allowed in a list.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">value</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_query_string_values</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">DecodeOptions</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tokenize a raw query string into a flat ``Dict[str, Any]``.</span>

<span class="sd">    Responsibilities</span>
<span class="sd">    ----------------</span>
<span class="sd">    - Strip a leading &#39;?&#39; if ``ignore_query_prefix`` is True.</span>
<span class="sd">    - Normalize percent-encoded square brackets (``%5B/%5D``) (case-insensitive) so the key splitter can operate.</span>
<span class="sd">    - Split into parts using either a string delimiter or a regex delimiter.</span>
<span class="sd">    - Enforce ``parameter_limit`` (optionally raising).</span>
<span class="sd">    - Detect the UTF-8/Latin-1 charset via the ``utf8=â€¦`` sentinel when enabled.</span>
<span class="sd">    - For each ``key=value`` pair:</span>
<span class="sd">        * Decode key/value via ``options.decoder`` (default: percent-decoding using the selected ``charset``).</span>
<span class="sd">          Keys are passed with ``kind=DecodeKind.KEY`` and values with ``kind=DecodeKind.VALUE``; a custom decoder</span>
<span class="sd">          may return the raw token or ``None``.</span>
<span class="sd">        * Apply comma-split list logic to values (handled here). Index-based list growth from bracket segments is applied later in ``_parse_object``. When ``list_limit &lt; 0`` and ``raise_on_limit_exceeded=True``, any comma-split that would increase the list length raises immediately; otherwise the split proceeds.</span>
<span class="sd">        * Interpret numeric entities for Latin-1 when requested.</span>
<span class="sd">        * Handle empty brackets ``[]`` as list markers (wrapping exactly once).</span>
<span class="sd">        * Merge duplicate keys according to ``duplicates`` policy.</span>

<span class="sd">    The output is a *flat* dict (keys are full key-path strings). Higher-level structure is constructed later by</span>
<span class="sd">    ``_parse_keys`` / ``_parse_object``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">clean_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">ignore_query_prefix</span> <span class="k">else</span> <span class="n">value</span>
    <span class="c1"># Normalize %5B/%5D to literal brackets before splitting (case-insensitive).</span>
    <span class="c1"># Note: this operates on the entire query string (keys *and* values). Thatâ€™s</span>
    <span class="c1"># intentional: it keeps the splitter simple, and value tokens are subsequently</span>
    <span class="c1"># passed through the scalar decoder, so this replacement is safe.</span>
    <span class="n">clean_str</span> <span class="o">=</span> <span class="n">clean_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%5B&quot;</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%5b&quot;</span><span class="p">,</span> <span class="s2">&quot;[&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%5D&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%5d</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;]&quot;</span><span class="p">)</span>

    <span class="c1"># Compute an effective parameter limit (None means &quot;no limit&quot;).</span>
    <span class="n">limit</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">isinf</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">parameter_limit</span><span class="p">)</span> <span class="k">else</span> <span class="n">options</span><span class="o">.</span><span class="n">parameter_limit</span>  <span class="c1"># type: ignore [assignment]</span>

    <span class="c1"># Guard against non-positive limits early for clearer errors.</span>
    <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">limit</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Parameter limit must be a positive integer.&quot;</span><span class="p">)</span>

    <span class="n">parts</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Unlimited parameters: split fully</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">):</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">clean_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">clean_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">raise_on_limit_exceeded</span><span class="p">:</span>
            <span class="c1"># Split to at most limit+1 parts so we can detect overflow</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">):</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">clean_str</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">clean_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameter limit exceeded: Only </span><span class="si">{</span><span class="n">limit</span><span class="si">}</span><span class="s2"> parameter</span><span class="si">{</span><span class="s1">&#39;s&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2"> allowed.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Silent degrade: split fully, then take the first `limit` parts</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">):</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">clean_str</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">clean_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">delimiter</span><span class="p">)</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[:</span><span class="n">limit</span><span class="p">]</span>

    <span class="n">skip_index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># Keep track of where the utf8 sentinel was found</span>
    <span class="n">i</span><span class="p">:</span> <span class="nb">int</span>

    <span class="n">charset</span><span class="p">:</span> <span class="n">Charset</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">charset</span>

    <span class="c1"># Probe for `utf8=` charset sentinel and adjust decoding charset accordingly.</span>
    <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">charset_sentinel</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_part</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_part</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;utf8=&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">_part</span> <span class="o">==</span> <span class="n">Sentinel</span><span class="o">.</span><span class="n">CHARSET</span><span class="o">.</span><span class="n">encoded</span><span class="p">:</span>
                    <span class="n">charset</span> <span class="o">=</span> <span class="n">Charset</span><span class="o">.</span><span class="n">UTF8</span>
                <span class="k">elif</span> <span class="n">_part</span> <span class="o">==</span> <span class="n">Sentinel</span><span class="o">.</span><span class="n">ISO</span><span class="o">.</span><span class="n">encoded</span><span class="p">:</span>
                    <span class="n">charset</span> <span class="o">=</span> <span class="n">Charset</span><span class="o">.</span><span class="n">LATIN1</span>
                <span class="n">skip_index</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>

    <span class="c1"># Local, non-optional decoder reference for type-checkers</span>
    <span class="n">decoder_fn</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">decoder</span> <span class="ow">or</span> <span class="n">DecodeUtils</span><span class="o">.</span><span class="n">decode</span>

    <span class="c1"># Iterate over parts and decode each key/value pair.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">skip_index</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">part</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">bracket_equals_pos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;]=&quot;</span><span class="p">)</span>
        <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">bracket_equals_pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="n">bracket_equals_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Decode key and value with a key-aware decoder; skip pairs whose key decodes to None</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">key_decoded</span> <span class="o">=</span> <span class="n">decoder_fn</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">charset</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">DecodeKind</span><span class="o">.</span><span class="n">KEY</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key_decoded</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">key_decoded</span>
            <span class="n">val</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">strict_null_handling</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_decoded</span> <span class="o">=</span> <span class="n">decoder_fn</span><span class="p">(</span><span class="n">part</span><span class="p">[:</span><span class="n">pos</span><span class="p">],</span> <span class="n">charset</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">DecodeKind</span><span class="o">.</span><span class="n">KEY</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key_decoded</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key_decoded</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                <span class="n">_parse_array_value</span><span class="p">(</span>
                    <span class="n">part</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span>
                    <span class="n">options</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">decoder_fn</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">charset</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">DecodeKind</span><span class="o">.</span><span class="n">VALUE</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">val</span> <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">interpret_numeric_entities</span> <span class="ow">and</span> <span class="n">charset</span> <span class="o">==</span> <span class="n">Charset</span><span class="o">.</span><span class="n">LATIN1</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">_interpret_numeric_entities</span><span class="p">(</span>
                <span class="n">val</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># If the pair used empty brackets syntax and list parsing is enabled, force an array container.</span>
        <span class="c1"># Always wrap exactly once to preserve list-of-lists semantics when comma splitting applies.</span>
        <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">parse_lists</span> <span class="ow">and</span> <span class="s2">&quot;[]=&quot;</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>

        <span class="n">existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">obj</span>

        <span class="c1"># Combine/overwrite according to the configured duplicates policy.</span>
        <span class="k">if</span> <span class="n">existing</span> <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">duplicates</span> <span class="o">==</span> <span class="n">Duplicates</span><span class="o">.</span><span class="n">COMBINE</span><span class="p">:</span>
            <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">Utils</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">existing</span> <span class="ow">or</span> <span class="n">options</span><span class="o">.</span><span class="n">duplicates</span> <span class="o">==</span> <span class="n">Duplicates</span><span class="o">.</span><span class="n">LAST</span><span class="p">:</span>
            <span class="n">obj</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">return</span> <span class="n">obj</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_object</span><span class="p">(</span>
    <span class="n">chain</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span> <span class="n">val</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">DecodeOptions</span><span class="p">,</span> <span class="n">values_parsed</span><span class="p">:</span> <span class="nb">bool</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fold a flat key-path chain into nested containers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    chain:</span>
<span class="sd">        Key segments like ``[&quot;user&quot;, &quot;[tags]&quot;, &quot;[]&quot;]`` produced by the key splitter.</span>
<span class="sd">        Bracketed indices and empty brackets are preserved here.</span>
<span class="sd">    val:</span>
<span class="sd">        The (possibly preprocessed) leaf value.</span>
<span class="sd">    options:</span>
<span class="sd">        Decoding options governing list handling, depth, and index interpretation.</span>
<span class="sd">    values_parsed:</span>
<span class="sd">        Whether `val` has already been decoded and split; influences list handling.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Builds lists when encountering ``[]`` (respecting ``allow_empty_lists`` and null handling).</span>
<span class="sd">    - Converts bracketed **numeric** segments into list indices when allowed and within ``list_limit``.</span>
<span class="sd">    - When ``list_limit`` is negative, **numeric-indexed bracket segments** are treated as map keys</span>
<span class="sd">      (i.e., index-based list growth is disabled). Empty brackets (``[]``) still create lists unless</span>
<span class="sd">      ``raise_on_limit_exceeded`` is True; with ``raise_on_limit_exceeded=True``, any list-growth operation</span>
<span class="sd">      (empty brackets, comma-split, nested pushes) raises immediately.</span>
<span class="sd">    - Inside bracket segments, a custom key decoder may leave percent-encoded dots (``%2E/%2e``). When</span>
<span class="sd">      ``decode_dot_in_keys`` is True, these are normalized to ``.`` here. Topâ€‘level dot splitting is already</span>
<span class="sd">      handled by the splitter.</span>
<span class="sd">    - When list parsing is disabled and an empty segment is encountered, coerces to ``{&quot;0&quot;: leaf}`` to preserve round-trippability with other ports.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">current_list_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># If the chain ends with an empty list marker, compute current list length for limit checks.</span>
    <span class="c1"># Best-effort note:</span>
    <span class="c1">#   This is a conservative heuristic intended to help when we see patterns like `a[0][]=`,</span>
    <span class="c1">#   so `_parse_array_value` can enforce the list limit for the final `[]` push. The segments</span>
    <span class="c1">#   we receive in `chain` include bracket markers (e.g., `[&quot;a&quot;, &quot;[0]&quot;, &quot;[]&quot;]`), so</span>
    <span class="c1">#   `&quot;&quot;.join(chain[:-1])` is rarely a pure integer (e.g., `&quot;a[0]&quot;` raises `ValueError`),</span>
    <span class="c1">#   and we typically fall back to `0`. Thatâ€™s fine: it remains safe and conservative.</span>
    <span class="c1">#   We still:</span>
    <span class="c1">#     â€¢ enforce per-list length for already-allocated containers during tokenization in</span>
    <span class="c1">#       `_parse_query_string_values` (where we know the current length), and</span>
    <span class="c1">#     â€¢ enforce index-based growth limits inside this function when converting bracketed</span>
    <span class="c1">#       numeric segments into list indices.</span>
    <span class="c1">#   Keeping this lightweight probe matches the other ports and avoids costly look-ahead into</span>
    <span class="c1">#   parent structures while maintaining correct limit behavior.</span>
    <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;[]&quot;</span><span class="p">:</span>
        <span class="n">parent_key</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">parent_key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chain</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">parent_key</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">parent_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="n">parent_key</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">val</span><span class="p">)):</span>
            <span class="n">current_list_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">parent_key</span><span class="p">])</span>

    <span class="n">leaf</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="n">values_parsed</span> <span class="k">else</span> <span class="n">_parse_array_value</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">current_list_length</span><span class="p">)</span>

    <span class="c1"># Walk the chain from the leaf to the root, building nested containers on the way out.</span>
    <span class="n">i</span><span class="p">:</span> <span class="nb">int</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain</span><span class="p">))):</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">]]]</span>
        <span class="n">root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">chain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">root</span> <span class="o">==</span> <span class="s2">&quot;[]&quot;</span> <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">parse_lists</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">allow_empty_lists</span> <span class="ow">and</span> <span class="p">(</span><span class="n">leaf</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">strict_null_handling</span> <span class="ow">and</span> <span class="n">leaf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">leaf</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="c1"># Map `%2E`/`%2e` to a literal dot *inside bracket segments* when</span>
            <span class="c1"># `decode_dot_in_keys` is enabled. Even though `_parse_query_string_values`</span>
            <span class="c1"># typically percentâ€‘decodes the key (default decoder), a custom</span>
            <span class="c1"># `DecodeOptions.decoder` may return the raw token. In that case, `%2E` can</span>
            <span class="c1"># still appear here and must be normalized for parity with the Kotlin/C#/Swift/Dart ports.</span>
            <span class="c1"># (Topâ€‘level dot splitting is performed earlier by the key splitter.)</span>
            <span class="n">clean_root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">root</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;]&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">root</span>

            <span class="k">if</span> <span class="n">options</span><span class="o">.</span><span class="n">decode_dot_in_keys</span><span class="p">:</span>
                <span class="n">decoded_root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">clean_root</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%2E</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%2e</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">decoded_root</span> <span class="o">=</span> <span class="n">clean_root</span>

            <span class="c1"># Parse numeric segment to decide between dict key vs. list index.</span>
            <span class="n">index</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">decoded_root</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">options</span><span class="o">.</span><span class="n">parse_lists</span> <span class="ow">and</span> <span class="n">decoded_root</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">:</span> <span class="n">leaf</span><span class="p">}</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">root</span> <span class="o">!=</span> <span class="n">decoded_root</span>
                <span class="ow">and</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="n">decoded_root</span>
                <span class="ow">and</span> <span class="n">options</span><span class="o">.</span><span class="n">parse_lists</span>
                <span class="ow">and</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">options</span><span class="o">.</span><span class="n">list_limit</span>
            <span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">UNDEFINED</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="n">obj</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">decoded_root</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf</span>

        <span class="n">leaf</span> <span class="o">=</span> <span class="n">obj</span>

    <span class="k">return</span> <span class="n">leaf</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_keys</span><span class="p">(</span><span class="n">given_key</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">val</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">DecodeOptions</span><span class="p">,</span> <span class="n">values_parsed</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split a full key string into segments and dispatch to ``_parse_object``.</span>

<span class="sd">    Returns ``None`` for empty keys (mirrors upstream behavior).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">given_key</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">keys</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">DecodeUtils</span><span class="o">.</span><span class="n">split_key_into_segments</span><span class="p">(</span>
        <span class="n">original_key</span><span class="o">=</span><span class="n">given_key</span><span class="p">,</span>
        <span class="n">allow_dots</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">options</span><span class="o">.</span><span class="n">allow_dots</span><span class="p">),</span>
        <span class="n">max_depth</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span>
        <span class="n">strict_depth</span><span class="o">=</span><span class="n">options</span><span class="o">.</span><span class="n">strict_depth</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">_parse_object</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">values_parsed</span><span class="p">)</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">qs-codec</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Decoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../README.html#encoding">Encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../README.html#handling-none-values">Handling <code class="docutils literal notranslate"><span class="pre">None</span></code> values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../README.html#dealing-with-special-character-sets">Dealing with special character sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../README.html#rfc-3986-and-rfc-1738-space-encoding">RFC 3986 and RFC 1738 space encoding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">qs_codec</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Klemen Tusar.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>